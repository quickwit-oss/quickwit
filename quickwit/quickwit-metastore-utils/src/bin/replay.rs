// Copyright 2021-Present Datadog, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

use std::path::PathBuf;

use quickwit_metastore_utils::{GrpcCall, GrpcRequest};
use quickwit_proto::metastore::metastore_service_client::MetastoreServiceClient;
use quickwit_proto::tonic::transport::Channel;
use structopt::StructOpt;
use tokio::fs::File;
use tokio::io::AsyncBufReadExt;

async fn replay_grpc_request(
    client: &mut MetastoreServiceClient<Channel>,
    req: GrpcRequest,
) -> anyhow::Result<()> {
    match req {
        GrpcRequest::CreateIndexRequest(req) => {
            client.create_index(req).await?;
        }
        GrpcRequest::IndexMetadataRequest(req) => {
            client.index_metadata(req).await?;
        }
        GrpcRequest::ListIndexesMetadataRequest(req) => {
            client.list_indexes_metadata(req).await?;
        }
        GrpcRequest::DeleteIndexRequest(req) => {
            client.delete_index(req).await?;
        }
        GrpcRequest::ListSplitsRequest(req) => {
            client.list_splits(req).await?;
        }
        GrpcRequest::StageSplitsRequest(req) => {
            client.stage_splits(req).await?;
        }
        GrpcRequest::PublishSplitsRequest(req) => {
            client.publish_splits(req).await?;
        }
        GrpcRequest::MarkSplitsForDeletionRequest(req) => {
            client.mark_splits_for_deletion(req).await?;
        }
        GrpcRequest::DeleteSplitsRequest(req) => {
            client.delete_splits(req).await?;
        }
        GrpcRequest::AddSourceRequest(req) => {
            client.add_source(req).await?;
        }
        GrpcRequest::ToggleSourceRequest(req) => {
            client.toggle_source(req).await?;
        }
        GrpcRequest::DeleteSourceRequest(req) => {
            client.delete_source(req).await?;
        }
        GrpcRequest::LastDeleteOpstampRequest(req) => {
            client.last_delete_opstamp(req).await?;
        }
        GrpcRequest::ResetSourceCheckpointRequest(req) => {
            client.reset_source_checkpoint(req).await?;
        }
        GrpcRequest::DeleteQuery(req) => {
            client.create_delete_task(req).await?;
        }
        GrpcRequest::UpdateSplitsDeleteOpstampRequest(req) => {
            client.update_splits_delete_opstamp(req).await?;
        }
        GrpcRequest::ListDeleteTasksRequest(req) => {
            client.list_delete_tasks(req).await?;
        }
        GrpcRequest::ListStaleSplitsRequest(req) => {
            client.list_stale_splits(req).await?;
        }
    }
    Ok(())
}

#[derive(Debug, StructOpt)]
#[structopt(
    name = "replay",
    about = "A quickwit-metastore program to replay request log generated by proxy"
)]
struct Opt {
    #[structopt(
        long,
        default_value = "./replay-data/requests-partition-wikitenant.ndjson"
    )]
    file: PathBuf,
    #[structopt(long, default_value = "http://127.0.0.1:7281")]
    forward_to: String,
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let opt = Opt::from_args();
    let file = File::open(&opt.file).await?;
    let buffered = tokio::io::BufReader::new(file);
    let mut lines = buffered.lines();
    let mut client = MetastoreServiceClient::connect(opt.forward_to.clone()).await?;
    let mut i = 0;
    while let Some(line) = lines.next_line().await? {
        println!("line {i} = {line}");
        let grpc_call: GrpcCall = serde_json::from_str(&line)?;
        replay_grpc_request(&mut client, grpc_call.grpc_request).await?;
        i += 1;
    }
    Ok(())
}
